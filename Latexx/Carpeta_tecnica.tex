\documentclass{report}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage[top=2cm]{geometry}
\usepackage{tikz}
\usepackage{etoolbox}
\usepackage[spanish]{babel}
\usepackage[hidelinks]{hyperref}
\usepackage{enumitem}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{xcolor}
\usepackage{textgreek}
\usepackage{listings}
\usepackage{float}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{siunitx}
\usetikzlibrary{shapes.geometric, arrows.meta, positioning, fit, calc}

\usetikzlibrary{shapes.geometric, arrows.meta, positioning, calc}

\tikzstyle{startstop} = [ellipse, minimum width=2cm, minimum height=0.8cm, text centered, draw=black, fill=blue!20, font=\small\bfseries]
\tikzstyle{process} = [rectangle, minimum width=2.5cm, minimum height=0.8cm, text centered, draw=black, fill=purple!15, font=\scriptsize]
\tikzstyle{decision} = [diamond, minimum width=2cm, minimum height=0.8cm, text centered, draw=black, fill=orange!20, font=\scriptsize, aspect=2]
\tikzstyle{score} = [rectangle, rounded corners, minimum width=2cm, minimum height=0.8cm, text centered, draw=black, fill=green!15, font=\scriptsize]
\tikzstyle{indicator} = [rectangle, rounded corners, minimum width=2cm, minimum height=0.8cm, text centered, draw=black, fill=yellow!20, font=\scriptsize\bfseries]
\tikzstyle{arrow} = [thick,->,>=Stealth]

\setlength{\fboxsep}{0pt}  % elimina el espacio interno
\setlength{\fboxrule}{1pt} % grosor del borde

\renewcommand{\contentsname}{\Huge Índice General}
\renewcommand{\listfigurename}{\Huge Índice de Figuras}
\definecolor{C}{HTML}{2A4190}
\definecolor{Y}{HTML}{FC9B32}

\fancypagestyle{plain}{%
  \fancyhf{}%
  \fancyhead[c]{\includegraphics[height=0.4cm]{logo.png}}%
  \fancyhead[L]{\textbf{\footnotesize OIB Sleep 2025}}%
  \fancyhead[R]{\textbf{\footnotesize E.E.S.T N°7 IMPA "T.R.Q."}}%
  \renewcommand{\footrulewidth}{0.4pt}
  \fancyfoot[C]{\thepage}%
}

% Aplicar el estilo a todas las páginas
\pagestyle{plain}
\renewcommand{\headrulewidth}{0.4pt}

\begin{document}
\begin{center}
    \includegraphics[width=11cm]{logo_OIB_croped.PNG}
    \\[1cm]
    {\Huge Carpeta Técnica} \\[0.5cm]
    {\huge 7mo 2da Comision A \\[0.5cm] Año 2025} \\
    \LARGE Bourlot Ezequiel \\
    Fernandez Lorenzo \\
    Domoñi Federico\\
    Vignetta Joaquin\\
\end{center}

\newpage

\tableofcontents 

\newpage
\listoffigures

\newpage
\chapter[\Large Preámbulo]{Preámbulo}

\section[large Nuestro contacto]{\LARGE Nuestro Contacto}
\noindent
\\
\href{https://www.instagram.com/oibsleep}{%
    \includegraphics[width=3cm]{Contacto/instagram.png}%
} \raisebox{1.25cm}{\Huge\ \ @oibsleep}
\\[0.3cm]
\href{mailto:oibsleep@gmail.com}{%
    \includegraphics[width=3cm]{Contacto/gmail.png}%
}\raisebox{1.25cm}{\Huge\ \ oibsleep@gmail.com}
\\[0.3cm]
\href{https://oib-sleep.vercel.app}{%
    \includegraphics[width=3cm]{Contacto/chrome.png}%
}\raisebox{1.25cm}{\Huge\ \ oib-sleep.vercel.app}
\\[0.3cm]
\href{https://github.com/impatrq/OIB_Sleep}{%
    \includegraphics[width=3cm]{Contacto/github.png}%
}\raisebox{1.25cm}{\Huge\ \ github.com/impatrq/OIB\_Sleep}%
\\

\section[large ¿Quienes somo?]{\LARGE Quienes somos?}


\setlength{\parskip}{1.5em}

% ---------- Integrante 1 ----------
\begin{minipage}{0.45\linewidth}
    \includegraphics[width=\linewidth, height=0.6\textheight, keepaspectratio]{Nosotros/Bourlot.jpg}
\end{minipage}
\hfill
\begin{minipage}{0.5\linewidth}
    \textbf{\Large Bourlot Ezequiel} \\[4pt]
    \includegraphics[height=0.8cm]{Contacto/instagram.png} \hspace{0.3cm}
    \includegraphics[height=0.8cm]{Contacto/linkedin.png} \hspace{0.3cm}
    \includegraphics[height=0.8cm]{Contacto/gmail.png} \\[10pt]
    \textit{\large Encargado del diseño electrónico, programación y control térmico del sistema.}
\end{minipage}

% ---------- Integrante 2 ----------
\begin{minipage}{0.45\linewidth}
    \includegraphics[width=\linewidth, height=0.6\textheight, keepaspectratio]{Nosotros/Domoñi.jpg}
\end{minipage}
\hfill
\begin{minipage}{0.5\linewidth}
    \textbf{\Large Federico Domoñi} \\[4pt]
    \includegraphics[height=0.8cm]{Contacto/instagram.png} \hspace{0.3cm}
    \includegraphics[height=0.8cm]{Contacto/linkedin.png} \hspace{0.3cm}
    \includegraphics[height=0.8cm]{Contacto/gmail.png} \\[10pt]
    \textit{\large Responsable del diseño mecánico y estructura del sistema de tanques.}
\end{minipage}

\newpage

% ---------- Integrante 3 ----------
\begin{minipage}{0.45\linewidth}
    \includegraphics[width=\linewidth, height=0.6\textheight, keepaspectratio]{Nosotros/Fernandez.jpg}
\end{minipage}
\hfill
\begin{minipage}{0.5\linewidth}
    \textbf{\Large Fernández Lorenzo} \\[4pt]
    \includegraphics[height=0.8cm]{Contacto/instagram.png} \hspace{0.3cm}
    \includegraphics[height=0.8cm]{Contacto/linkedin.png} \hspace{0.3cm}
    \includegraphics[height=0.8cm]{Contacto/gmail.png} \\[10pt]
    \textit{\large Encargado de documentación técnica, cálculos térmicos y presentación.}
\end{minipage}

% ---------- Integrante 4 ----------
\begin{minipage}{0.45\linewidth}
    \includegraphics[width=\linewidth, height=0.6\textheight, keepaspectratio]{Nosotros/Vignetta.jpg}
\end{minipage}
\hfill
\begin{minipage}{0.5\linewidth}
    \textbf{\Large Vignetta Joaquín} \\[4pt]
    \includegraphics[height=0.8cm]{Contacto/instagram.png} \hspace{0.3cm}
    \includegraphics[height=0.8cm]{Contacto/linkedin.png} \hspace{0.3cm}
    \includegraphics[height=0.8cm]{Contacto/gmail.png} \\[10pt]
    \textit{\large Responsable del diseño visual, edición de video y comunicación del proyecto.}
\end{minipage}

\newpage
\thispagestyle{empty} % sin número ni encabezado

\newgeometry{left=0cm, right=0cm, top=5cm, bottom=0cm}
\begin{figure}[H]
    \centering
    \includegraphics[width=22cm]{fotos/grupal.png}
\end{figure}
\restoregeometry

\section[large Docentes a cargo]{\LARGE Docentes a cargo}
\begin{itemize} [label=$\star$]
\Large
    \item Medina Sergio
    \item Carlassara Fabrizio
    \item Palmier Diego
    \item Bianco Carlos 
    \item Arguello Gabriel
    \item Solomiewicz Federico
\end{itemize}

\section[\large Agradecimientos]{\Large agradecimientos}
\noindent
\large
Agradecemos a la Asociación Cooperadora del IMPA.\\
Agradecemos a Simmons Por el colchón, que fue lo principal en nuestro proyecto\\
Agradecemos a layer by layer por los acoples para las mangueras\\
Agradecemos al personal docente de la institución por el inmenso apoyo que nos brindaron.


\section[\large Lenguajes usados]{\Large Lenguajes usados}
\begin{itemize} [label=$\bullet$]
    \item HTML5 \raisebox{-0.1cm} {\includegraphics[height=0.4cm] {lenguajes/html-5}}
    \item CSS3 \raisebox{-0.06cm} {\includegraphics[height=0.4cm] {lenguajes/css-3}}
    \item JavaSCript \raisebox{-0.1cm} {\includegraphics[height=0.4cm]{lenguajes/js}}
    \item Python \raisebox{-0.1cm} {\includegraphics[height=0.4cm] {lenguajes/python}}
    \item C++ \raisebox{-0.1cm} {\includegraphics[height=0.4cm] {lenguajes/c-}}
    \item LaTeX \raisebox{-0.1cm} {\includegraphics[height=0.4cm] {lenguajes/LaTeX_logo.svg}}
\end{itemize}

\section[\large Programas utilizados]{\Large Programas utilizados}
\begin{itemize} [label=$\bullet$]
    \item Visual Studio Code \raisebox{-0.1cm} {\includegraphics[height=0.4cm] {programas/vscode.png}}
    \item OverLeaf \raisebox{-0.06cm} {\includegraphics[height=0.4cm] {programas/overleaf}}
    \item PlatformIO \raisebox{-0.06cm} {\includegraphics[height=0.4cm] {programas/PlatformIO}}
    \item Raspberry PI Imager \raisebox{-0.07cm} {\includegraphics[height=0.4cm] {programas/PI}}
    \item PowerShell \raisebox{-0.07cm} {\includegraphics[height=0.4cm] {programas/PowerShell}}
    \item Ubuntu WSL \raisebox{-0.07cm} {\includegraphics[height=0.4cm] {programas/Ubuntu}}
    \item KiCad \raisebox{-0.07cm} {\includegraphics[height=0.4cm] {programas/KiCad}}
    \item Blender \raisebox{-0.1cm} {\includegraphics[height=0.4cm] {programas/Blender}}
    \item AutoCAD \raisebox{-0.07cm} {\includegraphics[height=0.4cm] {programas/AutoCAD}}
    \item Ultimaker cura \raisebox{-0.15cm}{\includegraphics[width=0.6cm]{programas/Ultimaker_cura.png}}
    \item Fusion3D \raisebox{-0.07cm} {\includegraphics[height=0.4cm] {programas/Fusion}}
    \item Word \raisebox{-0.07cm} {\includegraphics[height=0.4cm] {programas/Word}}
    \item Figma \raisebox{-0.07cm} {\includegraphics[height=0.4cm] {programas/Figma}}
    \item Ibis Paint \raisebox{-0.05cm} {\includegraphics[height=0.4cm] {programas/Ibis}}
\end{itemize}

\newpage

\chapter[\Large Introducción]{Introducción}


\section[\large ¿Que es OIBsleep?]{\Huge ¿Que es \textcolor{C}{OIB}\textcolor{Y}{sleep}?}
\large{
La cama ortopédica OIB sleep Es un colchón de uso hospital o personal que cuenta con sistema de calefacción/refrigeración que se regula mediante diferentes mediciones del paciente.
 Esta cama sirve para mejorar la calidad de sueño y prevenir enfermedades como la migraña al regular la temperatura en búsqueda de mantener el sueño REM (profundo) la mayor cantidad de tiempo posible. También se busca solucionar diferentes problemas de salud mediante esta regulación como, por ejemplo:
 \begin{itemize} [label=$\bullet$]
\item Pacientes con problemas de circulación entre ellos diabéticos o personas con problema de artritis suelen tener manos y pies fríos, y pueden no notar bien si están demasiado fríos o calientes (especialmente en el caso de la neuropatía diabética).
\item Adultos mayores, ya que la regulación de la temperatura disminuye con la edad.
\item Personas con fibromialgia o dolor crónico, el calor puede aliviar el dolor muscular y articular mientras que el frío reduce la inflamación.
\item Personas con problemas de sueño como insomnio o despertares nocturnos debido a la temperatura
 \end{itemize}
Se puede conseguir regular la temperatura del colchón mediante un sistema con tubos de agua que se regule con mediciones que se hacen con el colchón mismo o con una pulsera. Esto le ayudaría a los hospitales a mantener a varios pacientes en una misma habitación con las temperaturas necesarias para cada uno.
}

\section[\large Utilidades del proyecto]{\Huge Utilidades del proyecto}
Utilidades del proyecto:
OIB sleep es un proyecto planteado para hospitales que busca ayudar a las personas que tienen problemas debido a la falta de sueño y también a quienes la temperatura puede ayudar con sus respectivas enfermedades.
Tomamos la temperatura como base, ya que El entorno térmico es uno de los factores más importantes que pueden afectar el sueño humano''. Los efectos típicos de la exposición al calor o al frío son un aumento del estado de vigilia y una disminución del sueño de movimientos oculares rápidos (REM) y del sueño de ondas lentas.


\section[\large Impacto en Argentina]{\Huge Impacto en Argentina}
En Argentina, los problemas relacionados con el sueño representan un desafío creciente para la salud pública. 
Según un estudio de la Universidad Favaloro, \textbf{el 75\% de la población presenta algún tipo de alteración del sueño}, lo cual evidencia la necesidad de soluciones innovadoras que contribuyan a mejorar el descanso y la calidad de vida.  

\subsection{Impacto en la salud pública}
\begin{itemize} [label=$\bullet$]
    \item Mejora la calidad del sueño, reduciendo riesgos asociados a insomnio, migrañas y problemas cardiovasculares.  
    \item Favorece a pacientes con enfermedades crónicas como artritis, fibromialgia, diabetes y problemas de circulación, donde la regulación térmica es un factor clave.  
    \item Contribuye al bienestar de adultos mayores, un grupo poblacional que representa más del 11\% de los argentinos y que suele tener dificultades para regular la temperatura corporal durante el descanso.  
\end{itemize}

\subsection{Impacto en hospitales y centros de salud}
\begin{itemize} [label=$\bullet$]
    \item Permite la \textbf{regulación de la temperatura individual en habitaciones compartidas}, lo cual mejora la atención personalizada y optimiza el uso de recursos.  
    \item Potencial ahorro energético al evitar climatizar espacios completos, reduciendo los costos operativos.  
\end{itemize}

\subsection{Impacto en el mercado argentino}
\begin{itemize} [label=$\bullet$]
    \item Dada la alta prevalencia de trastornos del sueño, existe un \textbf{mercado amplio} para este tipo de tecnologías tanto en hospitales como en el uso domiciliario.  
    \item La producción nacional del sistema puede fomentar la \textbf{industria tecnológica local}, generando empleo y reduciendo costos de importación.  
\end{itemize}


\section[\large ¿Por qué OIBsleep?]{\Huge ¿Por qué \textcolor{C}{OIB}\textcolor{Y}{sleep}?}

\subsection{Usuarios que ayuda}
OIB Sleep está diseñado para mejorar la salud del sueño tanto en entornos hospitalarios como domésticos. Esto se logra a través de la regulación inteligente de la temperatura, ayudando a grupos como:
\begin{itemize}
    \item adutlos mayores
    \item Personas diabéticas
    \item Personas con insomnio
    \item Personas con fibromialgia
\end{itemize}

\subsection{Limitaciones de los métodos tradicionales}
El aire acondicionado, la estufa y otros métodos permiten modificar la temperatura del ambiente, pero ninguno de estos sistemas se adapta a las necesidades térmicas específicas de tu cuerpo ni responde a los cambios que experimentás mientras dormís. Estos métodos actúan de forma general sobre toda la habitación, sin tener en cuenta las variaciones naturales de la temperatura corporal a lo largo de la noche.
Además, al climatizar todo el espacio en lugar de centrarse únicamente en la persona, generan un consumo energético considerablemente mayor, lo que se traduce en un uso ineficiente de la energía y en un impacto ambiental más alto.

\subsection{La importancia del confort térmico durante el sueño}
La temperatura corporal no permanece constante durante el sueño: tiende a descender durante las fases más profundas y vuelve a elevarse de manera natural al acercarse el momento del despertar. Este ciclo térmico cumple un rol fundamental en la regulación del descanso y en la transición entre las distintas etapas del sueño.
Cuando el entorno no acompaña estos cambios —por ejemplo, si la habitación se mantiene demasiado cálida o demasiado fría—, el cuerpo debe esforzarse para compensar esa diferencia, lo que puede provocar microdespertares e interrumpir el descanso, reduciendo así la calidad y la continuidad del sueño.

\subsection{Una solución personalizada y directa}
OIB Sleep actúa directamente sobre la cama, en contacto con tu cuerpo, ajustando la temperatura del colchón en tiempo real según tus necesidades. De esta forma, el sistema responde de manera inteligente a los cambios térmicos que se producen durante el sueño, brindando una sensación de confort constante y personalizada.
Al intervenir únicamente sobre el colchón y no sobre el ambiente completo, permite alcanzar el confort térmico ideal con un consumo energético significativamente menor y sin alterar la temperatura del entorno.

\subsection{Confort desde el primer momento}
Más allá de su control inteligente, OIB Sleep ofrece funciones pensadas para maximizar el confort desde el primer momento. Permite precalentar la cama en invierno o enfriarla en verano antes de acostarte, logrando así que el colchón alcance la temperatura ideal incluso antes de que te recuestes.
De esta manera, transforma el momento de ir a dormir en una experiencia más placentera y personalizada, adaptándose a tus preferencias y al clima de cada estación.



\chapter[\Large Estructura]{Estructura}
\section[\large ¿Como esta estructurada la cama?]{\Huge ¿Como esta estructurada la cama?}
La cama cuenta con un colchón especialmente modificado en cuyo interior se instalaron Caños de cobre de 1/4 x 1 m esmaltados.Para colocarlos, utilizamos una plegadora que nos permitió insertar los tubos dentro del colchón realizando una serie de dobleces estratégicos, asegurando así una distribución uniforme del calor a lo largo de toda la superficie.
El sistema está compuesto por dos circuitos independientes: uno por el que circula agua caliente y otro por el que circula agua fría. Ambos tubos están conectados a sus respectivos tanques, lo que permite regular la temperatura del colchón de manera precisa y eficiente.

\begin{figure}[H]
\centering
\includegraphics[height=9cm]{Modelos 3D/bedmodel_bottom.png}
\caption{Vista inferior del modelo 3D de la cama con sistema de tubos}
\label{fig:cama_inferior}
\end{figure}

\section[\large ¿Como esta estructurado el brazalete?]{\Huge ¿Como esta estructurado el brazalete?}
El brazalete fue diseñado mediante un modelo 3D desarrollado en Blender y fabricado con material PLA, elegido por su equilibrio entre solidez, ligereza y flexibilidad.
El diseño incluye una serie de perforaciones distribuidas estratégicamente para permitir una adecuada ventilación y el paso del aire, garantizando así mayor comodidad durante su uso. En la siguiente imagen se puede observar la estructura y disposición de dichos orificios.

\begin{figure}[H]
\centering
\includegraphics[height=15.8cm]{Modelos 3D/Brazalete1.png}
\caption{Diseño 3D del brazalete - Vista frontal con perforaciones de ventilación}
\label{fig:brazalete_frontal}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[height=20cm]{Modelos 3D/Brazalete2.png}
\caption{Diseño 3D del brazalete - Vista lateral detallada}
\label{fig:brazalete_lateral}
\end{figure}

\newpage
Además, el brazalete está recubierto con una capa de goma espuma, lo que mejora la sensibilidad al tacto y aporta una sensación más cómoda al contacto con la piel.
Una vez impreso, el modelo fue lijado cuidadosamente para eliminar imperfecciones y lograr una superficie uniforme, optimizando tanto su estética como su funcionalidad.

\begin{figure}[H]
\centering
\includegraphics[height=10cm]{fotos/Brazaletes.png}
\caption{Brazaletes impresos y terminados}
\label{fig:brazaletes_terminados}
\end{figure}

El brazalete cuenta con un compartimiento destinado a alojar los diferentes sensores, diseñado para mantenerlos firmemente en su lugar y facilitar su conexión. Este compartimiento se fija al brazalete mediante abrojos (velcro), lo que permite retirarlo o ajustarlo fácilmente según sea necesario, garantizando al mismo tiempo estabilidad y comodidad durante el uso.

\begin{figure}[H]
\centering
\includegraphics[height=6.5cm]{fotos/brazalete.png}
\caption{Brazalete con compartimiento para sensores}
\label{fig:brazalete_sensores}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[height=10cm]{Modelos 3D/brazalete3.png}
\caption{Modelo 3D del compartimiento de sensores del brazalete}
\label{fig:brazalete_compartimiento}
\end{figure}


\section[\large ¿Como están estructurados los tanques?]{\Huge ¿Como están estructurados los tanques?}
En este proyecto se utilizan dos tanques principales, uno destinado al agua fría y otro al agua caliente, los cuales desempeñan un papel fundamental en el sistema de regulación térmica. Ambos tanques están aislados térmicamente con espuma de poliuretano, un material de alta densidad que permite mantener la temperatura interna estable, reduciendo significativamente las pérdidas de calor o de frío hacia el exterior.

El tanque de agua fría está equipado con seis celdas Peltier, cada una acompañada de su disipador de calor y su correspondiente cooler, también tienen una placa de metal del la parte del tanque para que se pase mejor el calor. Estas celdas funcionan mediante un principio termoeléctrico: al recibir corriente, una de sus caras absorbe el calor del interior del tanque (enfriando el agua), mientras que la otra lo disipa hacia afuera con la ayuda de los coolers. De esta forma, se logra un proceso de refrigeración activa y controlada, manteniendo la temperatura del agua dentro de los rangos deseados.

\begin{figure}[H]
    \centering
    \fbox{\includegraphics[width=0.8\linewidth]{fotos/tanque.png}}
    \caption{Tanque frío sin las celdas}
    \label{fig:tanquefrio}
\end{figure}



Por otro lado, el tanque de agua caliente cuenta con una resistencia eléctrica encargada de elevar la temperatura del agua. Este sistema está supervisado por un sensor de temperatura sumergible, que mide de manera continua el valor térmico del agua y permite pausar automáticamente el calentamiento cuando se alcanza una temperatura preestablecida, evitando sobrecalentamientos y optimizando el consumo energético.

En conjunto, ambos tanques trabajan de forma complementaria dentro del sistema, proporcionando un control térmico eficiente y preciso, esencial para garantizar el confort y la estabilidad del entorno en el que se implementa el proyecto.

\subsection{¿Como están colocados?}

\subsection{Cálculos de temperatura para el agua fría}

El sistema de enfriamiento del tanque de agua fría se basa en la utilización de celdas Peltier TEC1-12706, cada una con una capacidad aproximada de transferencia de calor ($Q_c$) de 60 W cuando opera con una diferencia de temperatura de 10 °C y alimentada a 12 V con un consumo de 6 A (potencia total 72 W). En el diseño propuesto se contempla un tanque con una capacidad total de 20 litros, debidamente aislado con espuma de poliuretano para minimizar las pérdidas térmicas. La temperatura ambiente promedio se considera de 30 °C, y el objetivo es reducir la temperatura del agua a 10 °C.

El agua, con una masa de aproximadamente 20 kg (considerando una densidad de 1 kg/L), requiere una extracción de energía térmica calculada mediante la ecuación:

\[
Q = m \cdot c \cdot \Delta T
\]

donde $c$ es el calor específico del agua (4186 J/kg·°C) y $\Delta T = 20$ °C (de 30 °C a 10 °C). De esta manera, la cantidad total de energía a retirar del sistema es de aproximadamente:

\[
Q = 20\,\text{kg} \times 4186\,\frac{\text{J}}{\text{kg}\cdot{}^\circ\text{C}} \times 20\,^\circ\text{C} = 1{,}674{,}400\,\text{J}
\]

Cada celda Peltier TEC1-12706 puede retirar alrededor de 60 W (60 J/s) en condiciones óptimas; sin embargo, considerando las ineficiencias y pérdidas térmicas del sistema, se estima una eficiencia real del 40 %, lo que reduce la capacidad efectiva de enfriamiento a unos 24 W por celda.

Para el sistema implementado, se utilizan \textbf{6 celdas Peltier TEC1-12706}, por lo que la potencia total efectiva de enfriamiento es:

\[
P = 6 \times 24\,\text{W} = 144\,\text{W} = 144\,\text{J/s}
\]

En estas condiciones, el tiempo teórico requerido para reducir la temperatura del agua de 30 °C a 10 °C sería:

\[
t = \frac{1\,674\,400\,\text{J}}{144\,\text{J/s}} \approx 11\,625\,\text{s} \approx 3\,\text{h}\,13\,\text{min}.
\]

No obstante, en la práctica, debido a pérdidas adicionales por conducción, eficiencia variable de las celdas y disipación incompleta del calor en la cara caliente, el tiempo real estimado de enfriamiento se sitúa entre \textbf{3,5 y 4 horas}. Con esta configuración, el sistema logra no solo enfriar el agua desde 30 °C hasta los 10 °C, sino también mantenerla estable a esa temperatura, incluso con una temperatura ambiente de 30 °C, gracias al aislamiento térmico del tanque.

Para el control térmico, el sistema utiliza sensores de temperatura \textbf{DS18B20} sumergidos en el tanque de agua fría y otro sensor en la parte interna del tanque de agua caliente para compensar el control térmico global del circuito hidráulico. Los sensores DS18B20 permiten una precisión de $\pm 0.5$ °C, facilitando una regulación exacta de la temperatura. La lectura de los sensores y el control de activación de las celdas Peltier se realiza mediante una \textbf{Raspberry Pi}, que además activa los relés asociados a cada grupo de celdas según las condiciones térmicas programadas.

\chapter[\Large Circuitos]{Circuitos}
\section[\large Resumen]{\Huge Resumen}
Para el correcto funcionamiento del proyecto fue necesario implementar distintos circuitos electrónicos encargados de controlar los diversos sistemas que lo componen. El centro de control principal está basado en una Raspberry Pi Zero 2 W, la cual coordina y administra el comportamiento de todos los componentes del sistema.

Esta placa actúa como el cerebro del proyecto, gestionando la activación de las bombas de agua, el control de las válvulas y el funcionamiento de los módulos de refrigeración y calefacción del colchón. Su tarea es asegurar que cada elemento se encienda o apague en el momento que se necesite, de acuerdo con las necesidades de temperatura determinadas por el algoritmo de control.

Además, la Raspberry Pi se comunica de forma inalámbrica mediante Wi-Fi con la pulsera inteligente del usuario, desde la cual recibe datos en tiempo real sobre parámetros relevantes. Esta información es utilizada por el sistema para ajustar dinámicamente la temperatura del colchón, logrando así un mayor confort y eficiencia energética durante el descanso.
\subsection{Pulsera}
La pulsera cuenta con un módulo ESP32 Mini que se encarga de transmitir de manera inalámbrica la información hacia una Raspberry Pi utilizando conectividad Wi-Fi, estableciendo así una comunicación eficiente y continua entre ambos dispositivos. A la ESP32 Mini se encuentran conectados tres sensores mediante el bus de comunicación I²C, cada uno con una función específica dentro del sistema: un sensor de temperatura AHT10, encargado de registrar las variaciones térmicas del entorno y del cuerpo del usuario; un acelerómetro MMA845Q , utilizado para detectar y analizar los movimientos y la posición corporal; y un sensor de ritmo cardíaco Max30102, que permite medir la frecuencia cardíaca en tiempo real.
Toda la información obtenida por estos sensores es procesada por la ESP32 Mini. Una vez procesados, los resultados son enviados a la Raspberry Pi, que se encarga de realizar el cálculo del estado de sueño del usuario y determinar la temperatura óptima requerida para mantener el confort durante el descanso, utilizando algoritmos de análisis de datos. garantizando un funcionamiento inteligente, autónomo y adaptable a las condiciones individuales de cada usuario.

\begin{figure}[H]
\centering
\includegraphics[width=14cm]{Esquematicos/image.png}
\caption{Esquemático del circuito de la pulsera}
\label{fig:EsquematicoPulsera}
\end{figure}

\vspace{1cm}

\begin{figure}[H]
\centering
\includegraphics[width=10cm]{PCBs/PulseraPCB.jpg}
\caption{PCB del circuito de la pulsera}
\label{fig:PCBPulsera}
\end{figure}

\subsection{Bombas de agua}
El circuito de bombeo está formado por dos módulos idénticos que permiten la conmutación y alimentación de las bombas mediante control digital desde la Raspberry Pi, cada módulo integra un relé electromecánico modelo SRD-12VDC-SL-C accionado a 12 V para aislar la carga de la lógica de control, un transistor BC337 empleado como interruptor de baja impedancia para manejar la bobina del relé desde un pin GPIO de la Raspberry Pi y los componentes de protección y polarización necesarios para un funcionamiento seguro y fiable, entre estos se consideran la resistencia de base para limitar la corriente hacia la base del BC337, un diodo 1N4007 conectado en paralelo con la bobina del relé para absorber picos inductivos y proteger el transistor.

\begin{figure}[H]
\centering
\includegraphics[height=14cm]{Esquematicos/bombarele.png}
\caption{Esquemático del circuito de las bombas de agua}
\label{fig:Esquematicobombarele}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[height=12cm]{PCBs/BombaPCB.jpg}
\caption{PCB del circuito de las bombas de agua}
\label{fig:PCBBombas}
\end{figure}

\subsection{Valvulas/Resistencia}
El circuito encargado del control de las válvulas y de la resistencia del calefón está diseñado bajo el mismo principio de funcionamiento que el utilizado en el sistema de bombas, empleando un relé y un transistor como elementos principales de conmutación y control. Sin embargo, a diferencia del circuito anterior, en este caso los dispositivos controlados operan con tensión de red de 220 V, por lo que la llave de conmutación del relé trabaja directamente sobre la línea de 220 V en lugar de hacerlo sobre una de 12 V, garantizando así la capacidad de manejar las cargas de mayor potencia que requieren estos componentes.

El relé es accionado mediante un transistor BC337, que actúa como interfaz entre la lógica de control de la Raspberry Pi y el circuito de potencia, permitiendo aislar eléctricamente la señal de control de los niveles de tensión elevados. En la entrada de control proveniente de la Raspberry Pi se incorpora una resistencia de 1 kΩ, cuya función principal es limitar la corriente hacia la base del transistor y proteger tanto al microcontrolador como al propio circuito de conmutación y un diodo en paralelo a la bobina del rele, asegurando un funcionamiento estable y seguro en todo momento.

\begin{figure}[H]
\centering
\includegraphics[height=9cm]{Esquematicos/valvula.jpg}
\caption{Esquemático del circuito de las valvulas y resistencia}
\label{fig:EsquematicoValvulasResistencia}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[height=9cm]{PCBs/valvulaPCB.jpg}
\caption{PCB del circuito de las valvulas y resistencia}
\label{fig:PCBvalvulasResistencia}
\end{figure}

\subsection{Raspberry Pi Zero 2 W}
Esta placa constituye el núcleo principal de control de todos los sistemas, siendo el elemento encargado de coordinar, procesar y ejecutar las distintas funciones automatizadas del conjunto. Su diseño integra una serie de salidas de 3.3 V y de tierra (GND) destinadas a la alimentación de los módulos y sensores periféricos, además de contar con pines GPIO programables, utilizados para emitir señales de control hacia los diferentes actuadores del sistema, entre ellos las bombas, válvulas y mecanismos de regulación térmica. Asimismo, dispone de una interfaz de comunicación I²C, mediante la cual se establecen las conexiones con los sensores de temperatura distribuidos en las distintas secciones del sistema, permitiendo una adquisición de datos precisa y sincronizada.

La placa tiene como función principal ejecutar el algoritmo de control de sueño, el cual recibe y procesa la información proveniente del módulo ESP32 Mini instalado en la pulsera del usuario. A partir de los datos recopilados por los sensores de temperatura, ritmo cardíaco y movimiento, el algoritmo realiza un análisis integral que permite determinar la temperatura ideal del entorno para optimizar el descanso del usuario. Una vez obtenida esta temperatura objetivo, la placa se encarga de activar y regular los diferentes sistemas asociados, tales como calefacción, refrigeración o circulación de agua, enviando las órdenes correspondientes a cada componente mediante las salidas de control.

Este diseño garantiza una integración completa entre la etapa de sensado y la de actuación, logrando una operación eficiente, segura y adaptable a las condiciones variables del entorno y las necesidades del usuario. Además, su arquitectura modular facilita futuras actualizaciones o ampliaciones del sistema, permitiendo incorporar nuevos sensores o funciones sin modificar la estructura general del hardware.

\begin{figure}[H]
\centering
\includegraphics[height=9cm]{Esquematicos/Raspberry.jpg}
\caption{PCB del circuito de la Raspberry Pi Zero 2 W}
\label{fig:EsquematicoRaspberryPi}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[height=10cm]{PCBs/RaspberryPCB.jpg}
\caption{PCB del circuito de la Raspberry Pi Zero 2 W}
\label{fig:PCBRaspberryPi}
\end{figure}

\subsection{Celdas de Peltier y Coolers}

El sistema de enfriamiento del tanque de agua fría se basa en el uso de \textbf{celdas Peltier} combinadas con \textbf{coolers} que actúan como disipadores de calor para evitar el sobrecalentamiento de los módulos. Este conjunto permite mantener una temperatura baja y estable dentro del tanque, garantizando un rendimiento eficiente y seguro durante el funcionamiento.

En total, el sistema cuenta con \textbf{seis celdas Peltier modelo TEC1-12706}, seleccionadas por su capacidad de enfriar de manera efectiva mediante el principio termoeléctrico. Estas celdas están dispuestas estratégicamente para maximizar la transferencia térmica y optimizar la distribución del frío dentro del tanque.

Cada celda se encuentra acompañada por su respectivo \textbf{cooler y disipador de aluminio}, cuya función principal es evacuar el calor generado en la cara caliente de la Peltier, asegurando así su correcto desempeño y prolongando su vida útil.

La alimentación eléctrica del sistema se realiza mediante una \textbf{fuente de 12V y 40Ah}, modelo \textbf{FG-40M}, la cual provee la corriente necesaria para el funcionamiento simultáneo de las seis celdas. Las conexiones se establecen en \textbf{paralelo}, lo que permite mantener una tensión constante en cada módulo y equilibrar el consumo total del sistema, garantizando estabilidad y eficiencia energética.

Este diseño proporciona un método de refrigeración controlado, confiable y adaptable, ideal para mantener las condiciones térmicas requeridas por el sistema principal del proyecto.


\chapter[\Large Código]{Código}      

\section[\large Resumen]{\Huge Resumen}
Una de las partes más vitales del proyecto es el desarrollo del código, ya que representa el núcleo lógico que permite la comunicación, el procesamiento de datos y la toma de decisiones dentro del sistema. La arquitectura del software se divide en cuatro módulos principales, cada uno con una función específica y complementaria que, en conjunto, garantizan el correcto funcionamiento de la cama inteligente.

El primer módulo es el Presence Detector, encargado de analizar en tiempo real si hay una persona sobre la cama. Para ello, realiza una fusión de datos provenientes de distintos sensores —como temperatura, movimiento y ritmo cardíaco— con el fin de estimar de manera precisa la presencia o ausencia del usuario. Este componente es fundamental, ya que su salida condiciona el funcionamiento de los demás módulos.

El segundo módulo, denominado analyzer.py, es responsable de ejecutar todos los cálculos del algoritmo principal. A partir de la información recibida del Presence Detector y de los sensores, este componente determina las acciones a tomar para mantener la temperatura del colchón dentro del rango de confort del usuario. En función de las condiciones detectadas, el módulo decide si se debe activar el sistema de enfriamiento o el de calentamiento del agua, buscando siempre optimizar la experiencia de descanso.

El tercer módulo es el Smart Bed Controller, el cual actúa como intermediario entre el software lógico y el hardware físico. Su función es enviar señales de control —en forma de valores binarios (1 o 0)— hacia los tanques de agua fría y caliente y a sus valvulas electricas, activando o desactivando los relés correspondientes, tambien apaga las bombas a cada cierto tiempo para que no se quemen. Gracias a este controlador, las decisiones tomadas por el algoritmo pueden traducirse en acciones concretas sobre el sistema hidráulico.

Por último, se encuentra el módulo correspondiente a la pulsera inteligente, que cumple un rol clave en la adquisición de datos fisiológicos del usuario. Este dispositivo portátil recopila información proveniente de sus sensores (como frecuencia cardíaca, temperatura y movimiento) y la transmite a la Raspberry Pi mediante el protocolo MQTT, utilizando una conexión Wi-Fi local. De esta forma, la cama inteligente dispone de datos actualizados y precisos para alimentar el algoritmo de control térmico.

En conjunto, estos cuatro módulos conforman un sistema integral capaz de detectar la presencia del usuario, analizar su estado, tomar decisiones autónomas y ejecutar las acciones necesarias para ajustar la temperatura del colchón. Esta estructura modular permite un desarrollo escalable, fácil de mantener y adaptable a futuras mejoras del proyecto.

\section[\large Explicación Técnica Detallada - Presence Detector]{\Huge Explicación Técnica Detallada - Presence Detector}

\subsection{Arquitectura General del Sistema}

El módulo \texttt{presence\_detector.py} implementa un sistema de detección de presencia en cama inteligente mediante fusión multi-sensor, utilizando cinco indicadores independientes que se combinan para generar un nivel de confianza global.

\subsection{Clase Principal: BedPresenceDetector}

\subsubsection*{Atributos de Estado}

\textbf{Estado de presencia actual:}
\begin{itemize}
  \item \texttt{bed\_occupied (bool)}: Indica si la cama está ocupada actualmente.
  \item \texttt{presence\_confidence (float)}: Nivel de confianza de presencia en porcentaje (0-100).
  \item \texttt{presence\_history (list)}: Buffer circular que almacena los últimos N valores de confianza.
  \item \texttt{presence\_start\_time (float)}: Timestamp Unix del momento en que se detectó entrada a la cama.
\end{itemize}

\textbf{Valores de referencia (baseline):}
\begin{itemize}
  \item \texttt{baseline\_temperature (float)}: Temperatura de referencia de la cama vacía, actualizable dinámicamente.
  \item \texttt{baseline\_activity (float)}: Nivel de actividad de referencia (actualmente no utilizado).
\end{itemize}

\textbf{Parámetros configurables:}
\begin{itemize}
  \item \texttt{confidence\_threshold\_enter}: Umbral para detectar entrada (60\% por defecto).
  \item \texttt{confidence\_threshold\_exit}: Umbral para detectar salida (20\% por defecto).
  \item \texttt{thermal\_threshold}: Incremento térmico sobre baseline (1.5°C por defecto).
  \item \texttt{activity\_threshold}: Nivel mínimo de actividad (0.001 por defecto).
  \item \texttt{hr\_min} y \texttt{hr\_max}: Rango válido de frecuencia cardíaca (40–150 BPM).
  \item \texttt{history\_size}: Tamaño del buffer de historial (30 muestras).
  \item \texttt{confirmation\_time}: Muestras consecutivas necesarias para confirmar salida (15 muestras).
\end{itemize}

Todos los parámetros se cargan desde el módulo \texttt{bed\_config}, permitiendo ajuste sin modificar el código.

\subsection{Método Principal: \texttt{detect\_presence()}}

\subsubsection*{Flujo de Procesamiento}

El método recibe un diccionario \texttt{sensor\_data} con:
\begin{itemize}
  \item \texttt{bed\_temperature}: Lectura del sensor HTU21D.
  \item \texttt{activity}: Magnitud del vector del acelerómetro MMA8451.
  \item \texttt{heart\_rate}: Frecuencia cardíaca calculada por el MAX30102.
  \item \texttt{hr\_valid}: Booleano que indica si la medición de HR es confiable.
  \item \texttt{finger\_present}: Booleano indicando contacto físico con el sensor óptico.
\end{itemize}

\subsubsection*{Sistema de Puntuación Multi-Indicador}

\paragraph{1. Indicador Térmico (máximo 40 puntos)}
\begin{verbatim}
temp_elevation = bed_temp - baseline_temperature
\end{verbatim}

\textbf{Criterios:}
\begin{itemize}
  \item Si \texttt{temp\_elevation > thermal\_threshold}: +30 puntos.
  \item Si \texttt{temp\_elevation > thermal\_threshold * 2}: +10 puntos adicionales.
\end{itemize}

\textbf{Fundamento:} La presencia humana eleva la temperatura de la cama entre 1.5°C y 4°C.

\paragraph{2. Indicador de Movimiento (máximo 25 puntos)}
\begin{verbatim}
activity_score = min(25, int(activity * 25 / 0.1))
\end{verbatim}

\textbf{Fundamento:} Los micro-movimientos durante el sueño generan actividad detectable.

\paragraph{3. Indicador Cardiovascular (máximo 40 puntos)}

\textbf{Criterios:}
\begin{itemize}
  \item Si HR válida y en rango 40–150 BPM: +35 puntos.
  \item Si HR en rango de sueño (50–80 BPM): +5 puntos adicionales.
\end{itemize}

\textbf{Fundamento:} La frecuencia cardíaca válida confirma presencia humana con alta certeza.

\paragraph{4. Indicador de Contacto (máximo 20 puntos)}

\textbf{Criterios:}
\begin{itemize}
  \item Si \texttt{finger\_present == True}: +20 puntos.
\end{itemize}

\textbf{Fundamento:} Detecta contacto físico mediante señal infrarroja reflejada.

\paragraph{5. Indicador Temporal (máximo 10 puntos)}
\begin{verbatim}
avg_confidence = sum(presence_history[-5:]) / 5
\end{verbatim}

\textbf{Criterio:} Si el promedio de las últimas 5 muestras > 50\%, +10 puntos.

\textbf{Fundamento:} La presencia real genera señales consistentes en el tiempo.

\subsubsection*{Cálculo de Confianza Global}
\begin{verbatim}
confidence = min(sum(all_indicators), 100)
\end{verbatim}

La suma ponderada de indicadores se limita a 100\%, siendo tolerante a fallos parciales.

\subsection{Mecanismo de Histéresis}

\subsubsection*{Propósito}
Evita transiciones rápidas entre estados de presencia.

\subsubsection*{Implementación en \texttt{\_update\_presence\_state()}}

\textbf{Entrada (vacía → ocupada):}
\begin{itemize}
  \item Condición: \texttt{confidence >= threshold\_enter}
  \item Acción inmediata: activa ocupación y registra timestamp
\end{itemize}

\textbf{Salida (ocupada → vacía):}
\begin{itemize}
  \item Condición: \texttt{confidence <= threshold\_exit}
\item Confirmación: últimos \texttt{confirmation\_time} valores $\leq 30\%$

  \item Acción: cambia a vacía tras baja confianza sostenida
\end{itemize}

\textbf{Nota:} La asimetría evita falsas salidas durante quietud prolongada.

\subsection{Gestión del Baseline Térmico}

\subsubsection*{Inicialización}
El baseline se toma automáticamente con la primera lectura térmica.

\subsubsection*{Actualización Dinámica}
Cuando la cama está vacía:
\[
baseline = (1 - \alpha) \times baseline_{old} + \alpha \times temp_{current}
\]
con $\alpha = 0.05$.

\subsubsection*{Calibración Manual}
\begin{itemize}
  \item Toma N lecturas en 5 minutos.
  \item Calcula la mediana para eliminar outliers.
  \item Reemplaza el baseline actual.
\end{itemize}

\subsection{Métodos de Utilidad y Debugging}

\begin{itemize}
  \item \texttt{get\_presence\_summary()}: Retorna estado global.
  \item \texttt{get\_detailed\_indicators()}: Análisis granular de indicadores.
  \item \texttt{reset\_presence\_state()}: Limpia historial y banderas.
  \item \texttt{\_get\_time\_occupied()}: Calcula minutos desde detección de entrada.
\end{itemize}

\subsection{Consideraciones de Diseño}

\textbf{Fusión de Sensores:} Suma ponderada de sensores heterogéneos.\\
\textbf{Tolerancia a Fallos:} El sistema sigue operativo ante fallos parciales.\\
\textbf{Adaptabilidad Temporal:} Baseline térmico adaptable a cambios ambientales.\\
\textbf{Escalabilidad:} Parámetros configurables vía \texttt{bed\_config}.

\subsection{Retorno del Método Principal}

El método \texttt{detect\_presence()} retorna:
\begin{itemize}
  \item \texttt{occupied}: estado binario actual.
  \item \texttt{confidence}: nivel de confianza (\%).
  \item \texttt{indicators}: detalle de cada indicador.
  \item \texttt{time\_occupied}: minutos desde entrada.
  \item \texttt{temp\_elevation}: incremento térmico sobre baseline.
  \item \texttt{presence\_changed}: bandera de transición de estado.
\end{itemize}

Este formato estructurado facilita la integración con módulos superiores del sistema de cama inteligente.


\newgeometry{left=1cm, right=0cm, top=2cm, bottom=2cm}
\thispagestyle{empty}

\vspace{1cm}

\begin{tikzpicture}[node distance=1.2cm and 1cm]

% FILA 1 (Izquierda a Derecha)
\node (start) [startstop] {INICIO};
\node (init) [process, right=of start] {Inicializar\\Variables};
\node (detect) [process, right=of init] {detect\\presence};
\node (getdata) [process, right=of detect] {Obtener\\Datos Sensores};

% FILA 2 (Derecha a Izquierda)
\node (checkbase) [decision, below=of getdata] {Baseline\\establecido?};
\node (setbase) [score, left=of checkbase] {Establecer\\baseline};
\node (analyze) [process, left=of setbase] {Analizar 5\\Indicadores};
\node (thermal) [indicator, left=of analyze] {INDICADOR\\TÉRMICO};

% FILA 3 (Izquierda a Derecha)
\node (tempcheck) [decision, below=of thermal] {Elevación\\temp?};
\node (tempscore) [score, right=of tempcheck] {+30 puntos\\+10 bonus};
\node (movement) [indicator, right=of tempscore] {INDICADOR\\MOVIMIENTO};
\node (actcheck) [decision, right=of movement] {Actividad\\>threshold?};

% FILA 4 (Derecha a Izquierda)
\node (actscore) [score, below=of actcheck] {+0 a 25\\puntos};
\node (cardio) [indicator, left=of actscore] {INDICADOR\\CARDIOVASCULAR};
\node (hrcheck) [decision, left=of cardio] {HR válida\\40-150?};
\node (hrscore) [score, left=of hrcheck] {+35 puntos\\+5 bonus};

% FILA 5 (Izquierda a Derecha)
\node (contact) [indicator, below=of hrscore] {INDICADOR\\CONTACTO};
\node (fingercheck) [decision, right=of contact] {Dedo\\presente?};
\node (fingerscore) [score, right=of fingercheck] {+20\\puntos};
\node (temporal) [indicator, right=of fingerscore] {INDICADOR\\TEMPORAL};

% FILA 6 (Derecha a Izquierda)
\node (histcheck) [decision, below=of temporal] {Confianza\\promedio\\>50\%?};
\node (tempscore2) [score, left=of histcheck] {+10\\puntos};
\node (calculate) [process, left=of tempscore2] {Calcular\\Confianza\\Total};
\node (update) [process, left=of calculate] {update\\presence\\state};

% FILA 7 (Izquierda a Derecha)
\node (occcheck) [decision, below=of update] {Cama\\ocupada?};
\node (entrycheck) [decision, right=of occcheck] {Confianza\\>=entrada?};
\node (enter) [process, right=of entrycheck] {\textcolor{green}{$\checkmark$} PRESENCIA\\DETECTADA};
\node (exitcheck) [decision, right=of enter] {Confianza\\<=salida?};

% FILA 8 (Derecha a Izquierda)
\node (confirm) [decision, below=of exitcheck] {Últimas 15\\<30\%?};
\node (exit) [process, left=of confirm] {\textcolor{red}{$\times$} AUSENCIA\\DETECTADA};
\node (return) [process, left=of exit] {Retornar\\Resultado};
\node (end) [startstop, left=of return] {FIN};

% CONEXIONES FILA 1
\draw [arrow] (start) -- (init);
\draw [arrow] (init) -- (detect);
\draw [arrow] (detect) -- (getdata);

% BAJADA A FILA 2
\draw [arrow] (getdata) -- (checkbase);
\draw [arrow] (checkbase) -- node[anchor=south, font=\tiny] {No} (setbase);
\draw [arrow] (checkbase.south) -- ++(0,-0.3) -| node[near start, anchor=south, font=\tiny] {Sí} (analyze);
\draw [arrow] (setbase) -- (analyze);
\draw [arrow] (analyze) -- (thermal);

% BAJADA A FILA 3
\draw [arrow] (thermal) -- (tempcheck);
\draw [arrow] (tempcheck) -- node[anchor=south, font=\tiny] {Sí/No} (tempscore);
\draw [arrow] (tempscore) -- (movement);
\draw [arrow] (movement) -- (actcheck);

% BAJADA A FILA 4
\draw [arrow] (actcheck) -- (actscore);
\draw [arrow] (actscore) -- (cardio);
\draw [arrow] (cardio) -- (hrcheck);
\draw [arrow] (hrcheck) -- node[anchor=south, font=\tiny] {Sí/No} (hrscore);

% BAJADA A FILA 5
\draw [arrow] (hrscore) -- (contact);
\draw [arrow] (contact) -- (fingercheck);
\draw [arrow] (fingercheck) -- node[anchor=south, font=\tiny] {Sí/No} (fingerscore);
\draw [arrow] (fingerscore) -- (temporal);

% BAJADA A FILA 6
\draw [arrow] (temporal) -- (histcheck);
\draw [arrow] (histcheck) -- node[anchor=south, font=\tiny] {Sí/No} (tempscore2);
\draw [arrow] (tempscore2) -- (calculate);
\draw [arrow] (calculate) -- (update);

% BAJADA A FILA 7
\draw [arrow] (update) -- (occcheck);
\draw [arrow] (occcheck) -- node[anchor=south, font=\tiny] {No} (entrycheck);
\draw [arrow] (entrycheck) -- node[anchor=south, font=\tiny] {Sí/No} (enter);
\draw [arrow] (enter) -- (exitcheck);

% BAJADA A FILA 8
\draw [arrow] (occcheck.south) -- ++(0,-0.3) -| node[near start, anchor=south, font=\tiny] {Sí} (exitcheck);
\draw [arrow] (exitcheck) -- node[anchor=west, font=\tiny] {Sí/No} (confirm);
\draw [arrow] (confirm) -- node[anchor=south, font=\tiny] {Sí/No} (exit);
\draw [arrow] (exit) -- (return);
\draw [arrow] (return) -- (end);

% CONEXIÓN DESDE ENTER A RETURN
\draw [arrow] (enter.south) -- ++(0,-0.3) -| (return);

\end{tikzpicture}
    \restoregeometry
    
\newpage

% Sección LaTeX para la documentación técnica del módulo analyzer.py
\section{Módulo de análisis de señales fisiológicas: \texttt{analyzer.py}}
\label{sec:analyzer}

\subsection{Arquitectura general}
El módulo \texttt{analyzer.py} constituye el núcleo de procesamiento analítico del sistema, centralizando las funciones encargadas del análisis de señales fisiológicas y series temporales de estados de sueño. Este módulo se diseñó siguiendo el principio de separación de responsabilidades: no implementa clases de estado ni gestiona operaciones de entrada/salida, limitándose exclusivamente a recibir datos previamente muestreados y preprocesados para devolver métricas cuantificables y eventos de interés clínico.

La única dependencia externa es la biblioteca NumPy, empleada para cálculo vectorizado y operaciones estadísticas básicas, lo que garantiza eficiencia computacional y portabilidad del código.

\subsection{Funciones principales}
A continuación se describen las funciones principales implementadas en el módulo, detallando sus parámetros de entrada, comportamiento esperado y fundamento teórico cuando aplique.

\begin{description}
  \item[\texttt{calculate\_rmssd(ibi)}] Calcula el RMSSD (\emph{root mean square of successive differences}) a partir de una secuencia de intervalos inter-latido (IBI). Esta métrica cuantifica la variabilidad de corto plazo del ritmo cardíaco y es un indicador reconocido de la actividad del sistema nervioso parasimpático~\cite{hrv_standards}. 
  
  La función retorna \texttt{None} si la ventana temporal no contiene suficientes muestras para el cálculo. Matemáticamente, el RMSSD se define como:
  \vspace{1cm}
  \begin{center}
      \[
    \mathrm{RMSSD} = \sqrt{\frac{1}{N-1}\sum_{i=1}^{N-1} (IBI_{i+1} - IBI_i)^2 }
      \]
  \end{center}
  \vspace{1cm}

  La implementación utiliza diferencias sucesivas (\texttt{np.diff}), elevación al cuadrado y cálculo de la raíz de la media aritmética.

  \item[\texttt{calculate\_sdnn(ibi)}] Calcula la desviación estándar (SDNN, \emph{standard deviation of NN intervals}) de la serie completa de IBI. Esta métrica describe la variabilidad global del ritmo cardíaco en la ventana temporal considerada y se obtiene mediante \texttt{np.std}. La función retorna \texttt{None} si la ventana contiene menos de dos muestras válidas.

  \item[\texttt{calculate\_stress\_score(hr, rmssd, sdnn, \ldots)}] Construye un índice heurístico de estrés en escala 0--100 mediante la integración ponderada de tres componentes fisiológicos: frecuencia cardíaca instantánea (\texttt{hr}), RMSSD y SDNN. El proceso de normalización se estructura así:
  \begin{itemize}
    \item \textbf{Frecuencia cardíaca (HR):} Se normaliza respecto a un umbral inferior fijo y un tope configurable, asumiendo una relación monotónica entre FC y nivel de estrés.
    \item \textbf{RMSSD y SDNN:} Se normalizan frente a valores máximos esperados. La contribución al índice de estrés se calcula como $1 - \text{valor normalizado}$, de modo que una mayor variabilidad cardíaca (asociada a mejor regulación autonómica) reduce la puntuación de estrés.
  \end{itemize}
  
  Los pesos por defecto asignados son 0.4 para HR, 0.3 para RMSSD y 0.3 para SDNN. Las normalizaciones se recortan al intervalo $[0, 1]$ para evitar valores fuera de rango. 
  
  \textbf{Nota:} Este índice es una aproximación heurística útil para sistemas de alerta temprana, pero requiere calibración experimental con población objetivo y validación clínica antes de su uso en entornos de producción.

  \item[\texttt{calculate\_sleep\_quality(sleep\_states, hr\_values=None, activity\_levels=None)}] Genera una puntuación de calidad del sueño en escala 0--100 mediante la integración de tres dimensiones fisiológicas y conductuales:
  
  \begin{enumerate}
    \item \textbf{Distribución de estados de sueño:} Se asume una codificación estándar (0=WAKE, 1=LIGHT\_SLEEP, 2=REM\_SLEEP, 3=DEEP\_SLEEP) con resolución temporal de un minuto por muestra. La función compara la distribución observada contra proporciones heurísticas óptimas documentadas en la literatura del sueño (aproximadamente 20\% sueño profundo, 25\% REM, 50\% sueño ligero, $<$5\% vigilia)~\cite{sleep_standards}.
    
    \item \textbf{Consistencia de frecuencia cardíaca:} Si se proporciona el vector \texttt{hr\_values}, se calcula la variabilidad (desviación estándar) durante las fases de sueño. Una menor variabilidad se interpreta como indicador de sueño consolidado y se mapea a una puntuación favorable.
    
    \item \textbf{Nivel de actividad motora:} Si se proporciona \texttt{activity\_levels}, se penaliza la actividad media elevada durante periodos de sueño, dado que refleja fragmentación o inquietud nocturna.
  \end{enumerate}
  
  La puntuación final combina estos tres componentes con pesos de 0.5, 0.25 y 0.25 respectivamente, y se recorta al intervalo $[0, 100]$. En caso de ausencia de datos de HR o actividad, la función emplea valores neutros para mantener la computabilidad con información parcial.

  \item[\texttt{analyze\_sleep\_transitions(sleep\_states)}] Cuantifica las transiciones entre estados de sueño consecutivos y retorna una tupla $(\text{transitions}, \text{fragmentation\_index})$, donde el índice de fragmentación se expresa como transiciones por hora de sueño (asumiendo 1 muestra = 1 minuto). Un índice elevado sugiere sueño fragmentado o inestable. La función retorna $(\text{None}, \text{None})$ si la entrada contiene menos de dos muestras.

  \item[\texttt{detect\_sleep\_onset(sleep\_states, window\_size=10, threshold=0.8)}] Identifica el índice temporal correspondiente al inicio del sueño mediante un algoritmo de ventana deslizante. Se considera iniciado el sueño cuando al menos el 80\% de las muestras en una ventana de tamaño configurable (por defecto 10 minutos) corresponden a estados de sueño (valor $>0$). Retorna el índice de inicio o \texttt{None} si no se satisface el criterio en toda la serie.

  \item[\texttt{detect\_wake\_periods(sleep\_states, min\_duration=5)}] Detecta segmentos contiguos de vigilia (estado WAKE = 0) y retorna una lista de tuplas $(start\_index, duration)$ para aquellos periodos cuya duración supera el umbral mínimo configurable (por defecto 5 minutos). Esta información es útil para caracterizar despertares nocturnos y estimar eficiencia del sueño.
\end{description}

\subsection{Entradas y salidas}
El módulo sigue convenciones consistentes para el manejo de datos:

\begin{itemize}
  \item Las funciones aceptan secuencias numéricas en formato lista Python o{numpy.ndarray}; internamente se realiza conversión implícita cuando es necesario.
  \item Las funciones \texttt{calculate\_rmssd} y \texttt{calculate\_sdnn} retornan un valor \texttt{float} o \texttt{None} en caso de datos insuficientes.
  \item Las funciones \texttt{calculate\_stress\_score} y \texttt{calculate\_sleep\_quality} retornan un \texttt{float} en el intervalo $[0, 100]$.
  \item La función \texttt{analyze\_sleep\_transitions} retorna una tupla $(\text{int}, \text{float})$ o $(\text{None}, \text{None})$.
  \item La función \texttt{detect\_sleep\_onset} retorna un índice entero o \texttt{None}.
  \item La función \texttt{detect\_wake\_periods} retorna una lista de tuplas $(start\_index, duration)$.
\end{itemize}

\textbf{Importante:} El módulo no implementa funcionalidades de lectura de sensores ni parsing de protocolos. Se asume que los datos de entrada están previamente alineados temporalmente, libres de valores no numéricos y han pasado por etapas de preprocesamiento básico.

\subsection{Supuestos y consideraciones temporales}
El diseño del módulo se basa en los siguientes supuestos operacionales:

\begin{itemize}
  \item La serie \texttt{sleep\_states} está uniformemente muestreada con resolución de un minuto por muestra.
  \item Los umbrales, pesos de ponderación y valores máximos empleados en las normalizaciones son aproximaciones heurísticas derivadas de la literatura científica disponible. Estos parámetros requieren calibración específica con datos reales del hardware implementado y características de la población objetivo.
  \item Las funciones no aplican filtrado de artefactos de forma automática. Señales con picos espurios o artefactos de medición en los IBI pueden introducir sesgos significativos en las métricas RMSSD y SDNN.
\end{itemize}

\subsection{Casos límite y estrategias de validación}
El módulo implementa manejo básico de casos límite mediante retorno de valores \texttt{None} o puntuaciones neutras cuando los datos son insuficientes. No obstante, no se realizan operaciones de interpolación, imputación ni recuperación de series corruptas.

Para garantizar robustez en entornos de producción, se recomienda:

\begin{itemize}
  \item Validar las entradas antes de invocar las funciones: verificar tipo numérico (\texttt{dtype}), longitudes mínimas y eliminar outliers en secuencias de IBI mediante criterios fisiológicos (por ejemplo, rechazar IBI $<$ 300\,ms o $>$ 2000\,ms).
  \item Desarrollar un conjunto de pruebas unitarias que incluya:
  \begin{itemize}
    \item Ventanas con datos insuficientes.
    \item Episodios de sueño continuo sin interrupciones.
    \item Despertares breves y frecuentes.
    \item Ausencia de señales opcionales (HR, actividad).
    \item Valores extremos de HR para verificar la saturación correcta en \texttt{calculate\_stress\_score}.
  \end{itemize}
\end{itemize}

\subsection{Recomendaciones para uso en producción}
Para la transición del módulo a entornos operacionales se sugieren las siguientes mejoras:

\begin{enumerate}
  \item \textbf{Validación explícita de entradas:} Implementar funciones auxiliares que verifiquen tipo numérico, rangos fisiológicamente plausibles y conversión forzada a \texttt{np.array} con manejo de excepciones informativo.
  
  \item \textbf{Filtrado de artefactos:} Incorporar un filtrado ligero o truncado estadístico (por ejemplo, Tukey's fences) en las secuencias de IBI previo al cálculo de RMSSD, reduciendo así la sensibilidad a artefactos de medición.
  
  \item \textbf{Parametrización configurable:} Externalizar umbrales y pesos a un archivo de configuración (por ejemplo, \texttt{config/bed\_config.py}) para facilitar ajustes por entorno sin modificación del código fuente.
  
  \item \textbf{Documentación ejecutable:} Incluir un script demostrativo en \texttt{examples/demo\_analyzer.py} y un conjunto de pruebas con \texttt{pytest} en \texttt{tests/test\_analyzer.py} que cubra tanto casos de uso típicos como escenarios límite.
\end{enumerate}

\subsection{Formato de salida y consumo de resultados}
Los módulos consumidores del análisis pueden esperar los siguientes formatos de retorno:

\begin{itemize}
  \item \textbf{Métricas escalares:} Valor \texttt{float} o \texttt{None} (para RMSSD, SDNN, índice de estrés, calidad del sueño).
  \item \textbf{Análisis de transiciones:} Tupla $(\text{int}, \text{float})$ representando conteo de transiciones e índice de fragmentación.
  \item \textbf{Periodos de vigilia:} Lista de tuplas $(start\_index, duration)$ con índices temporales y duraciones en minutos.
\end{itemize}

Estos valores son directamente integrables en pipelines de logging, sistemas de visualización en tiempo real y algoritmos de fusión multimodal implementados en módulos superiores de la arquitectura.

\subsection{Ejemplo de uso}
A continuación se presenta un fragmento de código ilustrativo del uso típico del módulo:

\begin{lstlisting}[language=Python, caption={Ejemplo de invocación de funciones del módulo analyzer.py}, label={lst:analyzer_example}]
from analyzer import (
    calculate_rmssd, calculate_sdnn, calculate_stress_score,
    calculate_sleep_quality, analyze_sleep_transitions,
    detect_sleep_onset, detect_wake_periods
)

# Datos de ejemplo: IBI en milisegundos
ibi = [800, 810, 795, 805, 790]
rmssd = calculate_rmssd(ibi)
sdnn = calculate_sdnn(ibi)
stress = calculate_stress_score(hr=72, rmssd=rmssd, sdnn=sdnn)

sleep_states = [0, 0, 1, 1, 3, 3, 2, 2, 1, 0]
onset = detect_sleep_onset(sleep_states)
wake_periods = detect_wake_periods(sleep_states)
quality = calculate_sleep_quality(sleep_states)

print(f"RMSSD: {rmssd:.2f} ms")
print(f"Stress Score: {stress:.1f}/100")
print(f"Sleep Onset: minuto {onset}")
print(f"Sleep Quality: {quality:.1f}/100")
\end{lstlisting}

\subsection{Referencias sugeridas}
Para fundamentar las métricas y umbrales empleados en este módulo, se recomienda consultar:

\begin{itemize}
  \item Task Force of the European Society of Cardiology and the North American Society of Pacing and Electrophysiology. ``Heart rate variability: standards of measurement, physiological interpretation and clinical use.'' \emph{Circulation}, 1996.
  \item Ohayon et al. ``National Sleep Foundation's sleep quality recommendations.'' \emph{Sleep Health}, 2017.
\end{itemize}

\begin{figure}[htbp]
\centering
\begin{tikzpicture}[
    node distance=1.5cm and 0.8cm,
    block/.style={rectangle, draw, fill=blue!20, text width=2.8cm, text centered, rounded corners, minimum height=1cm, font=\scriptsize},
    input/.style={rectangle, draw, fill=green!20, text width=2.8cm, text centered, rounded corners, minimum height=0.9cm, font=\scriptsize},
    output/.style={rectangle, draw, fill=orange!20, text width=2.8cm, text centered, rounded corners, minimum height=0.9cm, font=\scriptsize},
    arrow/.style={-Stealth, thick}
]

% Fila 1 (izquierda a derecha)
\node[input] (ibi) at (0,0) {Entrada: IBI\\{\tiny intervalos inter-latido}};
\node[block, right=of ibi] (rmssd) {calculate\\rmssd()\\{\tiny raiz cuadratica}};
\node[block, right=of rmssd] (sdnn) {calculate\\sdnn()\\{\tiny desv. estandar}};
\node[input, right=of sdnn] (hr) {Entrada: HR\\{\tiny freq. cardiaca}};

% Fila 2 (derecha a izquierda)
\node[block, below=1.8cm of hr] (stress) {calculate\\stress score\\{\tiny indice 0-100}};
\node[output, left=of stress] (stress_out) {Salida:\\Estres\\{\tiny score}};
\node[input, left=of stress_out] (sleep_in) {Entrada:\\sleep states\\{\tiny 0=WAKE}\\{\tiny 1-3=SLEEP}};

% Fila 3 (izquierda a derecha)
\node[block, below=1.8cm of sleep_in] (quality) {calculate\\sleep quality\\{\tiny dist+HR+act}};
\node[block, right=of quality] (transitions) {analyze sleep\\transitions\\{\tiny fragmentacion}};
\node[block, right=of transitions] (onset) {detect sleep\\onset\\{\tiny ventana deslizante}};

% Fila 4 (derecha a izquierda)
\node[block, below=1.8cm of onset] (wake) {detect wake\\periods\\{\tiny seg. vigilia}};
\node[output, left=of wake] (quality_out) {Salida:\\Calidad\\{\tiny 0-100}};
\node[output, left=of quality_out] (trans_out) {Salida:\\Transiciones\\{\tiny count}};
\node[output, left=of trans_out] (periods_out) {Salida:\\Periodos\\{\tiny tuplas}};

% Conexiones fila 1
\draw[arrow] (ibi) -- (rmssd);
\draw[arrow] (rmssd) -- (sdnn);
\draw[arrow] (sdnn) -- (hr);

% Conexion hacia abajo
\draw[arrow] (hr) -- (stress);

% Conexiones fila 2
\draw[arrow] (rmssd.south) |- ([yshift=-0.5cm]rmssd.south) -| (stress.north);
\draw[arrow] (sdnn.south) |- ([yshift=-0.5cm]sdnn.south) -| (stress.north);
\draw[arrow] (stress) -- (stress_out);
\draw[arrow] (stress_out) -- (sleep_in);

% Conexion hacia abajo
\draw[arrow] (sleep_in) -- (quality);

% Conexiones fila 3
\draw[arrow] (quality) -- (transitions);
\draw[arrow] (transitions) -- (onset);

% Conexion hacia abajo
\draw[arrow] (onset) -- (wake);

% Conexiones fila 4
\draw[arrow] (wake) -- (quality_out);
\draw[arrow] (quality_out) -- (trans_out);
\draw[arrow] (trans_out) -- (periods_out);

% Conexiones de sleep_states a multiples funciones
\draw[arrow] (sleep_in.south) -- ([yshift=-0.4cm]sleep_in.south) -| (quality.north);
\draw[arrow] ([yshift=-0.4cm]sleep_in.south) -| (transitions.north);
\draw[arrow] ([yshift=-0.4cm]sleep_in.south) -| (onset.north);

% Entradas adicionales opcionales
\node[input, below=0.3cm of quality] (hr_vals) {{\tiny (opcional)}\\hr values};
\node[input, below=0.3cm of transitions] (activity) {{\tiny (opcional)}\\activity levels};

\draw[arrow, dashed] (hr_vals) -- (quality);
\draw[arrow, dashed] (activity) -- (quality);

% Titulo
\node[font=\large\bfseries, anchor=south] at ([yshift=0.2cm]ibi.north west -| current bounding box.center) {Modulo analyzer.py - Flujo de Procesamiento};

\end{tikzpicture}
\caption{Diagrama de bloques del modulo analyzer.py mostrando el flujo de datos tipo serpiente.}
\label{fig:analyzer_diagram}
\end{figure}

\section{Explicación Detallada del Bed Controller}

Este proyecto implementa un sistema de monitoreo y control automático inteligente para una cama ortopédica médica. El sistema está diseñado para mejorar la calidad del sueño mediante el ajuste dinámico de la temperatura del colchón basándose en el estado de sueño del usuario, sus signos vitales y principios científicos de termorregulación corporal. La arquitectura del sistema integra múltiples sensores médicos de grado profesional con actuadores controlados por GPIO en una Raspberry Pi, todo orquestado mediante algoritmos de análisis en tiempo real.

\subsection{Fundamento Científico}

El sistema se basa en investigaciones científicas que demuestran que durante el sueño, la temperatura corporal experimenta un descenso natural de aproximadamente \SI{0.8}{\celsius}. Este descenso térmico no es uniforme, sino que varía según la fase de sueño en la que se encuentre la persona. Durante el sueño ligero inicial, la temperatura desciende entre \SIrange{0.2}{0.4}{\celsius}. En la fase REM, donde la actividad cerebral se asemeja al estado de vigilia, la temperatura se mantiene relativamente estable. Durante el sueño profundo, se alcanza el descenso máximo de \SI{0.8}{\celsius}. El sistema aprovecha este conocimiento para anticipar y facilitar las transiciones naturales entre estados de sueño mediante el control preciso de la temperatura del microclima de la cama.

Adicionalmente, estudios de variabilidad térmica han demostrado que existe una tolerancia natural de \SIrange{\pm 1}{\pm 2}{\celsius} en el microclima de la cama sin afectar el confort. El sistema utiliza estos parámetros para establecer rangos de confort personalizados según el estado de sueño detectado, evitando cambios bruscos que puedan interrumpir el descanso.

\subsection{Arquitectura de Sensores}

El sistema integra cuatro sensores principales que trabajan de manera coordinada para obtener una imagen completa del estado fisiológico del usuario y las condiciones ambientales.

\subsubsection{Sensor MAX30102}

El MAX30102 es un sensor óptico de oximetría de pulso que utiliza fotopletismografía para medir la frecuencia cardíaca y la saturación de oxígeno en sangre. Se comunica mediante protocolo I\textsuperscript{2}C en la dirección \texttt{0x57}. Este sensor es fundamental para la detección del estado de sueño, ya que la frecuencia cardíaca varía significativamente entre las diferentes fases del sueño. Durante el sueño profundo, la frecuencia cardíaca puede descender por debajo de 55~BPM, mientras que durante el sueño REM puede elevarse a niveles similares a los de vigilia (por encima de 70~BPM). El sensor también proporciona mediciones de saturación de oxígeno (SpO\textsubscript{2}), críticas para detectar posibles eventos de apnea del sueño. El sistema genera alertas cuando el SpO\textsubscript{2} cae por debajo del 90\%, indicando una posible condición de hipoxemia que requiere atención médica.

La implementación incluye validación de datos, verificando que el sensor detecte correctamente la presencia del dedo del usuario. Cuando no se detecta un dedo válido, el sistema recurre a valores simulados para mantener la operación continua, aunque con capacidades de análisis reducidas.

\subsubsection{Sensor HTU21D}

El HTU21D es un sensor de temperatura y humedad digital de alta precisión que se instala directamente en el colchón de la cama, comunicándose por I\textsuperscript{2}C en la dirección \texttt{0x40}. Este sensor es el componente crítico del sistema de control térmico, proporcionando lecturas en tiempo real de la temperatura del microclima de la cama. El sistema valida que las lecturas estén dentro del rango operativo seguro de \SIrange{15}{30}{\celsius} antes de utilizarlas para el control de válvulas.

El HTU21D también mide la humedad relativa del ambiente de la cama, un parámetro importante para el confort térmico general, aunque no se utiliza directamente en el algoritmo de control de temperatura. La combinación de temperatura y humedad proporciona información valiosa sobre las condiciones generales del microclima de la cama.

\subsubsection{Sensor AHT10}

El AHT10 es un sensor de temperatura corporal ubicado en una pulsera que lleva el usuario, comunicándose por I\textsuperscript{2}C en la dirección \texttt{0x38}. Este sensor es fundamental para detectar desviaciones de la temperatura corporal normal. El rango normal de temperatura corporal se establece entre \SIrange{35.0}{42.0}{\celsius}, con una temperatura basal promedio de \SI{36.8}{\celsius} según estudios clínicos.

El sistema implementa lógica avanzada de compensación térmica basada en las lecturas del AHT10. Cuando se detecta una temperatura corporal elevada (hipertermia), superior a \SI{37.5}{\celsius}, el sistema ajusta automáticamente la temperatura objetivo de la cama hacia abajo para ayudar a la termorregulación natural del cuerpo. En casos de fiebre (temperatura corporal $\geq$ \SI{38.0}{\celsius}), el ajuste de enfriamiento es más agresivo, con un descenso progresivo que puede alcanzar hasta \SI{3}{\celsius} más el exceso sobre \SI{38}{\celsius} multiplicado por 0.5. Inversamente, cuando se detecta hipotermia leve (temperatura corporal $\leq$ \SI{35.5}{\celsius}), el sistema activa un calentamiento progresivo para ayudar al cuerpo a recuperar su temperatura normal.

\subsubsection{Acelerómetro MMA8452Q}

El MMA8452Q es un acelerómetro triaxial de alta sensibilidad que detecta los movimientos corporales del usuario durante el sueño. Se comunica por I\textsuperscript{2}C en la dirección \texttt{0x1D} y proporciona lecturas de aceleración en los tres ejes ($X$, $Y$, $Z$). El sistema procesa estas lecturas para calcular un índice de actividad que es fundamental para la clasificación del estado de sueño.

El algoritmo de procesamiento de actividad implementa un modelo de integración temporal con decaimiento exponencial. Cada movimiento súbito incrementa el nivel de actividad instantáneamente, pero si no hay movimientos subsecuentes, la actividad decae gradualmente siguiendo una constante de tiempo configurable. Este comportamiento modela la forma en que percibimos la actividad física: un movimiento reciente tiene más relevancia que uno ocurrido hace varios segundos.

El cálculo específico compara la diferencia promedio de aceleración en los tres ejes con un umbral de actividad configurable. Cuando la diferencia supera el umbral, se registra un ``pico'' de actividad y el nivel se incrementa según un factor de fuerza de pico. Entre picos, el sistema espera un tiempo de retardo antes de comenzar el decaimiento exponencial, lo que evita que movimientos rápidos consecutivos se interpreten como períodos de calma.

\subsection{Detección de Estados de Sueño}

La clasificación del estado de sueño es el algoritmo central del sistema, combinando datos de actividad física y frecuencia cardíaca en un modelo de fusión sensorial. El sistema reconoce cuatro estados principales: despierto (\texttt{WAKE}), sueño ligero (\texttt{LIGHT\_SLEEP}), sueño REM (\texttt{REM\_SLEEP}) y sueño profundo (\texttt{DEEP\_SLEEP}).

\subsubsection{Clasificación por Actividad}

El primer nivel de clasificación utiliza el índice de actividad calculado desde el acelerómetro. Se establecen tres umbrales principales: 

\begin{itemize}[noitemsep]
    \item Si la actividad es menor a 0.01, se clasifica como actividad compatible con sueño profundo.
    \item Si está entre 0.01 y 0.008, se marca como ``\texttt{REM\_OR\_LIGHT}'' para análisis posterior.
    \item Si la actividad está entre 0.008 y 0.7, se clasifica como sueño ligero.
    \item Cualquier actividad superior a 0.7 indica estado de vigilia.
\end{itemize}

\subsubsection{Clasificación por Frecuencia Cardíaca}

Paralelamente, el sistema clasifica el estado basándose exclusivamente en la frecuencia cardíaca:

\begin{itemize}[noitemsep]
    \item Una frecuencia cardíaca inferior a 55~BPM sugiere sueño profundo.
    \item Frecuencias entre 55 y 75~BPM son compatibles con sueño ligero.
    \item Frecuencias superiores a 75~BPM indican vigilia o sueño REM.
\end{itemize}

\subsubsection{Fusión de Datos}

El algoritmo de fusión combina ambas clasificaciones mediante reglas lógicas basadas en el conocimiento fisiológico del sueño. Si tanto la actividad como la frecuencia cardíaca indican sueño profundo, el sistema clasifica con alta confianza como \texttt{DEEP\_SLEEP}. Este es el caso más inequívoco.

La detección de sueño REM es más compleja y representa una de las características más avanzadas del sistema. El sueño REM se caracteriza por una paradoja fisiológica: alta actividad cerebral (reflejada en frecuencia cardíaca elevada, típicamente $\geq$ 65~BPM) combinada con atonía muscular (parálisis temporal de los músculos voluntarios). El sistema detecta REM cuando la actividad física es muy baja (micro-movimientos menores a 0.008) pero la frecuencia cardíaca es relativamente alta. Esto distingue el REM del sueño profundo (baja actividad Y baja frecuencia cardíaca) y del estado despierto (alta actividad Y alta frecuencia cardíaca).

Cuando los indicadores son ambiguos o contradictorios, el sistema aplica reglas de desambiguación conservadoras. Por ejemplo, si la actividad sugiere sueño ligero pero la frecuencia cardíaca es muy alta, se clasifica como vigilia, asumiendo que la persona está despierta pero relativamente quieta.

\subsection{Sistema de Control de Temperatura}

El control de temperatura es el actuador principal del sistema, diseñado para mantener un microclima óptimo que facilite y preserve el sueño de calidad.

\subsubsection{Cálculo de Temperatura Objetivo}

El sistema mantiene zonas de confort diferenciadas para cada estado de sueño, basadas en investigación científica sobre termorregulación:

\begin{itemize}[noitemsep]
    \item \textbf{Vigilia:} \SIrange{21}{25}{\celsius}, reflejando la temperatura corporal basal alta típica del estado despierto.
    \item \textbf{Sueño ligero:} \SIrange{19}{23}{\celsius} para facilitar el descenso térmico inicial.
    \item \textbf{Sueño REM:} \SIrange{20}{24}{\celsius}, ligeramente más cálida debido a la actividad cerebral elevada.
    \item \textbf{Sueño profundo:} \SIrange{17}{21}{\celsius}, facilitando el descenso térmico máximo de \SI{0.8}{\celsius}.
\end{itemize}

El algoritmo calcula primero una temperatura base como el punto medio de la zona de confort del estado actual. Luego aplica un offset térmico científico: \SI{-0.3}{\celsius} para sueño ligero, \SI{0}{\celsius} para REM, \SI{-0.8}{\celsius} para sueño profundo, y \SI{0}{\celsius} para vigilia.

\subsubsection{Ajustes por Temperatura Ambiente}

El sistema ajusta la temperatura objetivo según la temperatura ambiente medida por el MAX30102:

\begin{itemize}[noitemsep]
    \item Si la temperatura ambiente supera \SI{25}{\celsius}, se aplica un ajuste de enfriamiento de \SI{-1.0}{\celsius}.
    \item Si la temperatura ambiente es inferior a \SI{15}{\celsius}, se aplica un ajuste de calentamiento de \SI{+1.0}{\celsius}.
\end{itemize}

\subsubsection{Compensación por Temperatura Corporal}

El ajuste más sofisticado se basa en la temperatura corporal del AHT10. El sistema detecta desviaciones de la temperatura corporal normal (\SI{36.8}{\celsius}) y ajusta la cama para ayudar a la termorregulación:

\begin{itemize}[noitemsep]
    \item \textbf{Fiebre} ($\geq$ \SI{38.0}{\celsius}): Enfriamiento agresivo de hasta \SI{-3.0}{\celsius} más un componente proporcional.
    \item \textbf{Hipertermia leve} (\SIrange{37.5}{38.0}{\celsius}): Ajuste moderado de \SI{-1.5}{\celsius} más un factor proporcional.
    \item \textbf{Hipotermia leve} ($\leq$ \SI{35.5}{\celsius}): Calentamiento progresivo de \SI{+2.0}{\celsius} más un componente proporcional.
\end{itemize}

\subsubsection{Control Predictivo}

Una característica avanzada del sistema es el control predictivo basado en el análisis de tendencias térmicas. El sistema mantiene un historial de las últimas 30 lecturas de temperatura (aproximadamente 10 minutos) y calcula la velocidad de cambio térmico en \si{\celsius\per\minute}. Con esta información, el algoritmo predice la temperatura en los próximos 5 minutos mediante extrapolación lineal.

Si la predicción indica que se alcanzará una temperatura fuera de los límites seguros, el sistema actúa preventivamente antes de que ocurra el problema. Este enfoque anticipativo mejora significativamente la estabilidad térmica y evita que el usuario experimente temperaturas incómodas.

\subsubsection{Análisis de Estabilidad Térmica}

El sistema calcula continuamente la varianza de las últimas 10 lecturas de temperatura. Una varianza alta (superior a un umbral de tolerancia configurable) indica inestabilidad térmica y activa un modo de estabilización que utiliza tolerancias más estrictas para el control de válvulas. Cuando la varianza es muy baja (menor a \SI{0.1}{\celsius\squared}), el sistema reporta estabilidad térmica óptima.

\subsubsection{Suavizado de Transiciones}

Para evitar cambios térmicos bruscos que puedan interrumpir el sueño, el sistema implementa un algoritmo de suavizado que limita la velocidad máxima de cambio de la temperatura objetivo. El cambio máximo permitido por ciclo de control se calcula como una fracción de la tolerancia de varianza térmica. Si el cambio calculado excede este límite, se aplica solo el cambio máximo permitido, distribuyendo la transición térmica a lo largo de múltiples ciclos.

\subsection{Control de Válvulas}

El sistema controla dos válvulas eléctricas de 220~V mediante relés conectados a pines GPIO de la Raspberry Pi: una válvula de agua caliente y una válvula de agua fría. Existe también un relé de seguridad general.

\subsubsection{Lógica de Control}

El algoritmo de control de válvulas implementa un controlador de banda muerta (\textit{deadband controller}). Se define una tolerancia térmica (típicamente $\pm$\SI{0.5}{\celsius}) alrededor de la temperatura objetivo:

\begin{itemize}[noitemsep]
    \item Si la temperatura actual está dentro de esta banda de tolerancia, ambas válvulas se cierran.
    \item Si la temperatura actual es inferior al límite inferior, se abre la válvula de agua caliente.
    \item Si la temperatura actual supera el límite superior, se abre la válvula de agua fría.
\end{itemize}

\subsubsection{Ajuste Dinámico de Tolerancia}

El sistema ajusta dinámicamente la tolerancia del controlador según el estado de sueño:

\begin{itemize}[noitemsep]
    \item \textbf{Sueño profundo:} Tolerancia ampliada en 50\% (de $\pm$\SI{0.5}{\celsius} a $\pm$\SI{0.75}{\celsius}).
    \item \textbf{Sueño REM:} Tolerancia reducida en 20\% (a $\pm$\SI{0.4}{\celsius}).
\end{itemize}

\subsubsection{Medidas de Seguridad}

El sistema implementa múltiples capas de seguridad críticas:

\begin{enumerate}[noitemsep]
    \item \textbf{Interlock de Válvulas:} Previene la apertura simultánea de ambas válvulas. Si se detecta esta condición, el sistema bloquea ambas válvulas y registra una alerta de seguridad.
    
    \item \textbf{Rangos de Temperatura Absolutos:} Todas las temperaturas objetivo se limitan a un rango absoluto de \SIrange{15}{30}{\celsius}.
    
    \item \textbf{Parada de Emergencia:} El método \texttt{emergency\_stop()} cierra inmediatamente todas las válvulas cuando se detectan condiciones críticas como frecuencias cardíacas peligrosamente altas ($>$120~BPM) o bajas ($<$40~BPM).
    
    \item \textbf{Validación de Sensores:} Antes de utilizar cualquier lectura de sensor, el sistema valida que el valor esté dentro de rangos físicamente plausibles.
\end{enumerate}

\subsubsection{Algoritmo de Confianza}

Cada indicador aporta un porcentaje de confianza al cálculo final. La confianza total se calcula como la suma ponderada de todos los indicadores activos. El sistema implementa histéresis en la detección:

\begin{itemize}[noitemsep]
    \item \textbf{Umbral para detectar entrada:} 60\% de confianza.
    \item \textbf{Umbral para detectar salida:} 20\% de confianza.
\end{itemize}

Esta asimetría reduce falsos positivos en la detección de entrada.

\subsection{Análisis Avanzado de Sueño}

El sistema implementa un conjunto sofisticado de algoritmos de análisis que proporcionan métricas cuantitativas de calidad de sueño y estrés fisiológico.

\subsubsection{Variabilidad de Frecuencia Cardíaca (HRV)}

El sistema calcula métricas estándar de HRV:

\begin{itemize}[noitemsep]
    \item \textbf{RMSSD} (\textit{Root Mean Square of Successive Differences}): Mide la variabilidad de corto plazo entre latidos consecutivos. Un RMSSD alto indica buena capacidad de adaptación del sistema nervioso autónomo.
    
    \item \textbf{SDNN} (\textit{Standard Deviation of NN intervals}): Mide la variabilidad general de todos los intervalos entre latidos. Valores más altos se asocian con mejor salud cardiovascular.
\end{itemize}

\subsubsection{Puntuación de Estrés}

El sistema calcula una puntuación de estrés de 0--100 combinando frecuencia cardíaca actual y métricas de HRV. Una frecuencia cardíaca elevada con HRV reducido indica alto estrés fisiológico:

\begin{itemize}[noitemsep]
    \item \textbf{Estrés alto:} Puntuación $>$ 70
    \item \textbf{Estrés medio:} Puntuación 40--70
    \item \textbf{Estrés bajo:} Puntuación $<$ 40
\end{itemize}

\subsubsection{Calidad de Sueño}

La métrica de calidad de sueño se calcula cuando hay suficiente historial de datos (al menos 30 muestras, equivalente a 1 hora de monitoreo). El algoritmo analiza la distribución de estados de sueño y compara con patrones ideales:

\begin{itemize}[noitemsep]
    \item Aproximadamente 20\% de sueño profundo
    \item 20--25\% de sueño REM
    \item El resto en sueño ligero
    \item Menos del 5\% de vigilia
\end{itemize}

La puntuación final de 0--100 se clasifica como:

\begin{itemize}[noitemsep]
    \item \textbf{Excelente:} $>$ 80
    \item \textbf{Buena:} 60--80
    \item \textbf{Regular:} 40--60
    \item \textbf{Deficiente:} $<$ 40
\end{itemize}

\subsubsection{Detección de Inicio de Sueño}

El sistema detecta automáticamente el momento en que el usuario transiciona de vigilia a sueño. La latencia de inicio de sueño (tiempo desde acostarse hasta dormirse) es un indicador importante:

\begin{itemize}[noitemsep]
    \item \textbf{Normal:} $<$ 15 minutos
    \item \textbf{Elevada:} 15--30 minutos
    \item \textbf{Muy elevada:} $>$ 30 minutos (posible insomnio)
\end{itemize}

\subsubsection{Análisis de Fragmentación de Sueño}

Cada 5 minutos, el sistema analiza las transiciones entre estados de sueño. El algoritmo calcula un índice de fragmentación normalizado por hora:

\begin{itemize}[noitemsep]
    \item \textbf{Muy consolidado:} $<$ 10 transiciones/hora
    \item \textbf{Consolidado:} 10--15 transiciones/hora
    \item \textbf{Ligeramente fragmentado:} 15--25 transiciones/hora
    \item \textbf{Muy fragmentado:} $>$ 25 transiciones/hora
\end{itemize}

\subsubsection{Detección de Despertares Nocturnos}

El sistema identifica períodos de vigilia durante el sueño que excedan una duración mínima configurable (típicamente 6--10 segundos). Se registra el número de despertares y el tiempo total en estado de vigilia. Más de 2 despertares o más de 30 minutos acumulados despierto se consideran indicadores de sueño interrumpido.

\subsubsection{Reporte Final de Sueño}

Al finalizar una sesión de monitoreo, el sistema genera un reporte completo que incluye:

\begin{enumerate}[noitemsep]
    \item \textbf{Duración Total:} Tiempo total de monitoreo desde que se detectó presencia.
    \item \textbf{Distribución de Estados:} Porcentajes y tiempos absolutos en cada estado.
    \item \textbf{Calidad Final de Sueño:} Puntuación 0--100 con interpretación cualitativa.
    \item \textbf{Análisis de Fragmentación:} Número total de transiciones e índice por hora.
    \item \textbf{Latencia de Sueño:} Tiempo hasta el inicio del sueño con evaluación.
    \item \textbf{Despertares Nocturnos:} Número de despertares y tiempo total despierto.
    \item \textbf{Recomendaciones Personalizadas:} Basadas en los resultados del análisis.
\end{enumerate}

\subsection{Integración y Flujo de Ejecución}

El sistema opera mediante un bucle asíncrono principal que se ejecuta cada 2 segundos. En cada iteración:

\begin{enumerate}[noitemsep]
    \item Se leen todos los sensores (MAX30102, HTU21D, AHT10, MMA8452Q).
    \item Se validan las lecturas y se filtran valores espurios.
    \item Se calcula el nivel de actividad integrado desde el acelerómetro.
    \item Se actualiza el detector de presencia con los datos actuales.
    \item Si se detecta presencia, se clasifica el estado de sueño actual.
    \item Se actualizan los historiales de datos para análisis temporal.
    \item Se calcula la temperatura objetivo basada en estado de sueño y compensaciones.
    \item Se ejecuta el controlador de válvulas para alcanzar la temperatura objetivo.
    \item Cada 30 segundos se ejecuta el análisis avanzado (HRV, estrés, calidad).
    \item Se muestra en consola el estado actual completo del sistema.
\end{enumerate}

Este ciclo continúa hasta que el usuario interrumpe el programa o se detecta una condición de error crítica. Al finalizar, se ejecuta el procedimiento de limpieza que cierra todas las válvulas, libera los recursos GPIO y genera el reporte final.

\subsection{Manejo de Errores y Robustez}

El sistema implementa múltiples capas de manejo de errores para garantizar operación continua incluso con fallos parciales de hardware:

\begin{itemize}[noitemsep]
    \item Cada sensor está envuelto en bloques \texttt{try-except} que capturan excepciones y permiten que el sistema continúe con valores simulados o el último valor válido conocido.
    \item Los pines GPIO se configuran con manejo de advertencias desactivado para evitar mensajes espurios en reconfiguración.
    \item El destructor de la clase asegura que incluso si el programa termina abruptamente, se ejecute la limpieza de recursos y la parada de emergencia de válvulas.
\end{itemize}

\newgeometry{left=1cm, right=0cm, top=2cm, bottom=2cm}
\thispagestyle{empty}

\begin{figure}[htbp]
\centering
\resizebox{\linewidth}{!}{%
\begin{tikzpicture}[
    node distance=1.0cm and 0.6cm,
    block/.style={rectangle, draw, fill=blue!18, text width=2.2cm, text centered, rounded corners, minimum height=0.8cm, font=\scriptsize},
    input/.style={rectangle, draw, fill=green!18, text width=2.2cm, text centered, rounded corners, minimum height=0.7cm, font=\scriptsize},
    output/.style={rectangle, draw, fill=orange!18, text width=2.2cm, text centered, rounded corners, minimum height=0.7cm, font=\scriptsize},
    arrow/.style={-Stealth, line width=0.7pt}
]

% Fila 1 (sensores, izquierda a derecha)
\node[input] (max) at (0,0) {MAX30102\\{\tiny HR / SpO2 / Ambient}};
\node[input, right=of max] (mma) {MMA8452Q\\{\tiny Acelerómetro}};
\node[input, right=of mma] (htu) {HTU21D\\{\tiny Temp cama / Humedad}};
\node[input, right=of htu] (aht) {AHT10 (opt.)\\{\tiny Temp corporal}};
\node[input, right=of aht] (presence) {presence\_detector\\{\tiny Presencia}};

% Fila 2 (fusión)
\node[block, below=1.6cm of mma] (fusion) {process\_sensor\_data\\{\tiny fusión + presencia + historiales}};

% Conexiones sensores -> fusión
\draw[arrow] (max) -- (fusion);
\draw[arrow] (mma) -- (fusion);
\draw[arrow] (htu) -- (fusion);
\draw[arrow] (aht) -- (fusion);
\draw[arrow] (presence) -- (fusion);

% Historiales (izquierda centro)
\node[output, left=1.0cm of fusion] (store) {Historiales\\{\tiny hr / activity / sleep / temps}};
\draw[arrow] (fusion.west) -- (store.east);

% Detección de sueño (izq medio, serpiente)
\node[block, below=1.6cm of store, xshift=-0.6cm] (sleepdet) {detect\_sleep\_state\\{\tiny actividad + HR}};
\draw[arrow] (fusion) |- (sleepdet);

% Análisis avanzado (centro derecha)
\node[block, right=2.9cm of sleepdet] (analyzer) {perform\_advanced\_analysis\\{\tiny HRV / stress / quality}};
\draw[arrow] (sleepdet) -- ++(0.4cm,0) |- (analyzer.west);
\draw[arrow] (store.south) -- ++(0,-0.5cm) -| (analyzer.west);

% Cálculo temperatura objetivo (abajo-centro)
\node[block, below=1.6cm of analyzer, xshift=-0.1cm] (target) {calculate\_target\_temperature\\{\tiny comfort + ambient + body}};
\draw[arrow] (analyzer) -- (target);

% Tendencias térmicas (derecha de target)
\node[block, right=2.1cm of target] (trend) {analyze\_thermal\_trends\\{\tiny predicción / varianza}};
\draw[arrow] (target) -- (trend);

% Control científico (centro inferior)
\node[block, below=1.6cm of trend, xshift=-0.4cm] (apply) {apply\_scientific\_thermal\_control\\{\tiny predictivo + tolerancias}};
\draw[arrow] (trend) -- (apply);
\draw[arrow] (target) |- (apply);

% Decisión de válvulas (derecha)
\node[block, right=3.2cm of apply] (control) {control\_valves\\{\tiny heat / cool / maintain}};
\draw[arrow] (apply) -- (control);

% Set valves -> actuadores
\node[block, right=of control] (setvalve) {set\_valve\_states\\{\tiny safety: no ambas}};
\draw[arrow] (control) -- (setvalve);

\node[block, below=0.7cm of setvalve] (gpio) {GPIO / Relés\\{\tiny HOT / COLD / SAFETY}};
\draw[arrow] (setvalve) -- (gpio);

\node[output, below=0.7cm of gpio] (actuators) {Actuadores\\{\tiny Válvulas / Seguridad}};
\draw[arrow] (gpio) -- (actuators);

% Emergency stop (izq de actuadores)
\node[block, left=2.0cm of actuators] (emergency) {emergency\_stop\\{\tiny cerrar todo}};
\draw[arrow] (fusion.south) |- (emergency.north);
\draw[arrow, red, thick] (emergency.east) -- ++(0.6cm,0) |- (gpio.west);

% Reporte final (abajo-izq)
\node[block, below=1.8cm of sleepdet, xshift=-0.1cm] (report) {generate\_sleep\_report\\{\tiny resumen / fragmentación / recomendaciones}};
\draw[arrow] (analyzer.south) -- ++(0,-0.4cm) -| (report.north);
\draw[arrow] (store.south) -- ++(0,-0.6cm) -| (report.east);

% Bucle de monitoreo (arriba-izq)
\node[input, above=0.6cm of max, xshift=-0.3cm] (start) {start\_monitoring\\{\tiny bucle 2s}};
\draw[arrow] (start) -- ++(0.6cm,0) |- (fusion.north);

% Conexiones auxiliares (discretas, en línea)
\node[input, below=0.4cm of target] (bodytemp) {{\tiny (opt)}\\AHT10 body};
\draw[arrow, dashed] (bodytemp) -- (target);

\node[input, below=0.4cm of analyzer] (hrvals) {{\tiny (opt)}\\HR history};
\draw[arrow, dashed] (hrvals) -- (analyzer);

% Leyenda compacta
\node[font=\footnotesize, anchor=north] at ([yshift=-1.1cm]actuators.south) {
  \begin{tabular}{l}
    Azul = Módulos / funciones \\
    Verde = Sensores / Entradas \\
    Naranja = Salidas / Historiales
  \end{tabular}
};

% Título muy compacto
\node[font=\normalsize\bfseries, anchor=south] at ([yshift=0.25cm]max.north -| current bounding box.center) {Smart Bed -- Diagrama (estrecho)};

\end{tikzpicture}%
}
\caption{Diagrama compacto (serpiente) del sistema de cama inteligente — versión ajustada para ancho de página.}
\label{fig:smartbed_diagram_narrow}
\end{figure}
\restoregeometry

\begin{thebibliography}{9}

\bibitem{REM}
Clininca Universidad de Navarra, 
\textit{¿Qué es el sueño REM?}, 
Disponible en:\url{https://www.cun.es/diccionario-medico/terminos/sueno-rem#:~:text=El%20sueño%20REM%20es%20una,de%20actividad%20cerebral%20y%20fisiológica.}

\bibitem{Cama inteligente}
Sleep Number, \textit{Una cama inteligente que monitorea los ronquidos y cambia de temperatura sola}, 
Disponible en:\url{https://www.infobae.com/america/tecno/2022/01/06/una-cama-inteligente-que-monitorea-los-ronquidos-y-se-calienta-sola}

\bibitem{refrigeración}
Radal., \textit{PELTIER TEC1-12706 Cómo montar una mini nevera produce flores de hielo}, 
Disponible en:\url{https://www.youtube.com/watch?v=C9LASZjX1Wc}

\bibitem{programación}
Simon Howroyd., \textit{ESP-IDF in CPP 10: Non-volatile Storage and Templates}, 
Disponible en:\url{https://www.youtube.com/watch?v=2C3rD9wiXFw&list=PLowIV8ZSSsAWjoPJomVi_s1ZMghc9gNn9}

\bibitem{tohoku}
Tohoku Fukushi University, 
\textit{Effects of thermal environment on sleep and circadian rhythm}, 
Disponible en: \url{https://jphysiolanthropol.biomedcentral.com/articles/10.1186/1880-6805-31-14#Abs1}

\end{thebibliography}



\end{document}